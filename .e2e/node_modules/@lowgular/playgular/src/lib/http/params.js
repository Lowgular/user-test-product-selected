"use strict";
/* eslint-disable no-case-declarations */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpParams = exports.HttpUrlEncodingCodec = void 0;
const matchers_1 = require("../matchers");
/**
 * Provides encoding and decoding of URL parameter and query-string values.
 *
 * Serializes and parses URL parameter keys and values to encode and decode them.
 * If you pass URL query parameters without encoding,
 * the query parameters can be misinterpreted at the receiving end.
 *
 *
 * @publicApi
 */
class HttpUrlEncodingCodec {
    /**
     * Encodes a key name for a URL parameter or query-string.
     * @param key The key name.
     * @returns The encoded key name.
     */
    encodeKey(key) {
        return standardEncoding(key);
    }
    /**
     * Encodes the value of a URL parameter or query-string.
     * @param value The value.
     * @returns The encoded value.
     */
    encodeValue(value) {
        return standardEncoding(value);
    }
    /**
     * Decodes an encoded URL parameter or query-string key.
     * @param key The encoded key name.
     * @returns The decoded key name.
     */
    decodeKey(key) {
        return decodeURIComponent(key);
    }
    /**
     * Decodes an encoded URL parameter or query-string value.
     * @param value The encoded value.
     * @returns The decoded value.
     */
    decodeValue(value) {
        return decodeURIComponent(value);
    }
}
exports.HttpUrlEncodingCodec = HttpUrlEncodingCodec;
function paramParser(rawParams, codec) {
    const map = new Map();
    if (rawParams.length > 0) {
        // The `window.location.search` can be used while creating an instance of the `HttpParams` class
        // (e.g. `new HttpParams({ fromString: window.location.search })`). The `window.location.search`
        // may start with the `?` char, so we strip it if it's present.
        const params = rawParams.replace(/^\?/, '').split('&');
        params.forEach((param) => {
            const eqIdx = param.indexOf('=');
            const [key, val] = eqIdx == -1
                ? [codec.decodeKey(param), '']
                : [
                    codec.decodeKey(param.slice(0, eqIdx)),
                    codec.decodeValue(param.slice(eqIdx + 1)),
                ];
            const list = map.get(key) || [];
            list.push(val);
            map.set(key, list);
        });
    }
    return map;
}
/**
 * Encode input string with standard encodeURIComponent and then un-encode specific characters.
 */
const STANDARD_ENCODING_REGEX = /%(\d[a-f0-9])/gi;
const STANDARD_ENCODING_REPLACEMENTS = {
    '40': '@',
    '3A': ':',
    '24': '$',
    '2C': ',',
    '3B': ';',
    '3D': '=',
    '3F': '?',
    '2F': '/',
};
function standardEncoding(v) {
    return encodeURIComponent(v).replace(STANDARD_ENCODING_REGEX, (s, t) => { var _a; return (_a = STANDARD_ENCODING_REPLACEMENTS[t]) !== null && _a !== void 0 ? _a : s; });
}
function valueToString(value) {
    return `${value}`;
}
/**
 * An HTTP request/response body that represents serialized parameters,
 * per the MIME type `application/x-www-form-urlencoded`.
 *
 * This class is immutable; all mutation operations return a new instance.
 *
 * @publicApi
 */
class HttpParams {
    constructor(options = {}) {
        this.updates = null;
        this.cloneFrom = null;
        this.encoder = options.encoder || new HttpUrlEncodingCodec();
        if (options.fromString) {
            if (options.fromObject) {
                throw new Error(`Cannot specify both fromString and fromObject.`);
            }
            const mapOfStrings = paramParser(options.fromString, this.encoder);
            this.map = [...mapOfStrings.keys()].reduce((a, k) => {
                const values = mapOfStrings.get(k);
                if (!values) {
                    return a;
                }
                return a.set(k, values.map((val) => (0, matchers_1.coerceRegexp)(val)));
            }, new Map());
        }
        else if (options.fromObject) {
            this.map = new Map();
            Object.keys(options.fromObject).forEach((key) => {
                const value = options.fromObject[key];
                // convert the values to strings
                const values = Array.isArray(value)
                    ? value.map((v) => (0, matchers_1.coerceRegexp)(v))
                    : [(0, matchers_1.coerceRegexp)(value)];
                this.map.set(key, values);
            });
        }
        else {
            this.map = null;
        }
    }
    /**
     * Reports whether the body includes one or more values for a given parameter.
     * @param param The parameter name.
     * @returns True if the parameter has one or more values,
     * false if it has no value or is not present.
     */
    has(param) {
        this.init();
        return this.map.has(param);
    }
    /**
     * Retrieves the first value for a parameter.
     * @param param The parameter name.
     * @returns The first value of the given parameter,
     * or `null` if the parameter is not present.
     */
    get(param) {
        this.init();
        const res = this.map.get(param);
        return res ? res[0] : null;
    }
    /**
     * Retrieves all values for a  parameter.
     * @param param The parameter name.
     * @returns All values in a string array,
     * or `null` if the parameter not present.
     */
    getAll(param) {
        this.init();
        return this.map.get(param) || null;
    }
    /**
     * Retrieves all the parameters for this body.
     * @returns The parameter names in a string array.
     */
    keys() {
        this.init();
        return Array.from(this.map.keys());
    }
    /**
     * Appends a new value to existing values for a parameter.
     * @param param The parameter name.
     * @param value The new value to add.
     * @return A new body with the appended value.
     */
    append(param, value) {
        if (!value) {
            return this;
        }
        return this.clone({ param, value, op: 'a' });
    }
    /**
     * Replaces the value for a parameter.
     * @param param The parameter name.
     * @param value The new value.
     * @return A new body with the new value.
     */
    set(param, value) {
        if (!value) {
            return this;
        }
        return this.clone({ param, value, op: 's' });
    }
    expectParamsFromUrlString(paramString) {
        var _a;
        this.init();
        if (this.map && this.map.size > 0 && paramString === undefined) {
            return false;
        }
        const paramsMap = this.buildQueryMap(paramString);
        let isMatchingAll = true;
        (_a = this.map) === null || _a === void 0 ? void 0 : _a.forEach((values, key) => {
            const actualValues = paramsMap.get(key);
            actualValues === null || actualValues === void 0 ? void 0 : actualValues.forEach((actualVal) => {
                values.forEach((value) => {
                    if (actualVal.match(value) === null) {
                        isMatchingAll = false;
                    }
                });
            });
        });
        return isMatchingAll;
    }
    buildQueryMap(url) {
        return paramParser(url, this.encoder);
    }
    clone(update) {
        const clone = new HttpParams({
            encoder: this.encoder,
        });
        clone.cloneFrom = this.cloneFrom || this;
        clone.updates = (this.updates || []).concat(update);
        return clone;
    }
    init() {
        if (this.map === null) {
            this.map = new Map();
        }
        if (this.cloneFrom !== null) {
            this.cloneFrom.init();
            this.cloneFrom
                .keys()
                .forEach((key) => this.map.set(key, this.cloneFrom.map.get(key)));
            this.updates.forEach((update) => {
                switch (update.op) {
                    case 'a':
                    case 's':
                        const base = (update.op === 'a' ? this.map.get(update.param) : undefined) ||
                            [];
                        base.push((0, matchers_1.coerceRegexp)(update.value));
                        this.map.set(update.param, base);
                        break;
                }
            });
            this.cloneFrom = this.updates = null;
        }
    }
}
exports.HttpParams = HttpParams;
//# sourceMappingURL=params.js.map