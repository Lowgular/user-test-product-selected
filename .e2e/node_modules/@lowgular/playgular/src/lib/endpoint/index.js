"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchRequestAndExpectResponse = exports.waitForAllResponses = exports.whenARequestHasFailure = exports.stubAndWaitForResponse = exports.whenARequestHasCompleted = exports.stubAllRequests = exports.stubARequest = exports.makeOkEndpoint = exports.makeUnauthorizedResponseStub = exports.makeCreatedResponseStub = exports.makeOkResponseStub = exports.makeNoContentResponseStub = void 0;
const tslib_1 = require("tslib");
const test_1 = require("@playwright/test");
const const_1 = require("../const");
const data_1 = require("../data");
const matchers_1 = require("../matchers");
const makeNoContentResponseStub = () => ({ status: 204 });
exports.makeNoContentResponseStub = makeNoContentResponseStub;
const makeOkResponseStub = (bodyStub) => ({
    status: 200,
    body: bodyStub,
});
exports.makeOkResponseStub = makeOkResponseStub;
const makeCreatedResponseStub = (bodyStub) => ({
    status: 201,
    body: bodyStub,
});
exports.makeCreatedResponseStub = makeCreatedResponseStub;
const makeUnauthorizedResponseStub = (bodyStub) => ({
    status: 401,
    body: bodyStub,
});
exports.makeUnauthorizedResponseStub = makeUnauthorizedResponseStub;
const makeOkEndpoint = (request, bodyStub) => (Object.assign(Object.assign({}, request), { responseStub: (0, exports.makeOkResponseStub)(bodyStub) }));
exports.makeOkEndpoint = makeOkEndpoint;
const stubARequest = (page, endpoint) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    yield page.route(endpoint.url, (route) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        if (route.request().method() === endpoint.method) {
            yield route.fulfill({
                status: (_a = endpoint.responseStub) === null || _a === void 0 ? void 0 : _a.status,
                body: JSON.stringify((_b = endpoint.responseStub) === null || _b === void 0 ? void 0 : _b.body),
            });
        }
    }));
});
exports.stubARequest = stubARequest;
const stubAllRequests = (page, requestsWithStubs) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    for (let i = 0; i < requestsWithStubs.length; i++) {
        yield (0, exports.stubARequest)(page, requestsWithStubs[i]);
    }
});
exports.stubAllRequests = stubAllRequests;
// TODO: Remove me
const whenARequestHasCompleted = (page, url, method) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    yield page.waitForResponse((resp) => resp.url() === url && resp.ok() && resp.request().method() === method);
});
exports.whenARequestHasCompleted = whenARequestHasCompleted;
const stubAndWaitForResponse = (page, responseStub, request) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    yield (0, exports.stubARequest)(page, {
        url: request.url,
        method: request.method,
        responseStub: {
            body: {
                data: responseStub.data,
                meta: responseStub.meta,
            },
        },
    });
    yield (0, exports.matchRequestAndExpectResponse)(page, request);
});
exports.stubAndWaitForResponse = stubAndWaitForResponse;
const whenARequestHasFailure = (page, url, method) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    yield page.waitForResponse((resp) => resp.url() === url &&
        resp.status() === 401 &&
        resp.request().method() === method);
});
exports.whenARequestHasFailure = whenARequestHasFailure;
const waitForAllResponses = (page, requests) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    for (let i = 0; i < requests.length; i++) {
        yield (0, exports.matchRequestAndExpectResponse)(page, requests[i]);
    }
});
exports.waitForAllResponses = waitForAllResponses;
const matchRequestAndExpectResponse = (page_1, request_1, ...args_1) => tslib_1.__awaiter(void 0, [page_1, request_1, ...args_1], void 0, function* (page, request, options = {}, response = {}) {
    const actualResponse = yield page.waitForResponse((resp) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const actualRequest = resp.request();
        const requestUrl = actualRequest.url();
        const requestMethod = actualRequest.method();
        const requestBody = actualRequest.postData();
        const requestHeaders = yield actualRequest.allHeaders();
        const urlParts = requestUrl.split('?');
        const baseUrl = urlParts[0];
        const paramString = urlParts.length > 1 ? urlParts[1] : undefined;
        return (baseUrl.match((0, matchers_1.coerceRegexp)(request.url)) !== null &&
            requestMethod === request.method &&
            (options.headers === undefined ||
                headersAreMatching(options.headers, requestHeaders)) &&
            (options.params === undefined ||
                options.params.expectParamsFromUrlString(paramString)) &&
            (request.body === undefined || bodyIsMatching(request.body, requestBody)));
    }), const_1.WAIT_CONFIG);
    if (response.statusCode) {
        (0, test_1.expect)(actualResponse.status()).toEqual(response.statusCode);
    }
    if (response.body) {
        (0, test_1.expect)(yield actualResponse.json()).toMatchObject(response.body);
    }
    return response;
});
exports.matchRequestAndExpectResponse = matchRequestAndExpectResponse;
const bodyIsMatching = (expectedBody, actualBodyString) => {
    if (actualBodyString === null) {
        return false;
    }
    const type = typeof expectedBody;
    if (type !== 'object') {
        return false;
    }
    const actualBody = JSON.parse(actualBodyString);
    return (0, data_1.objectsShouldIntercept)(expectedBody, actualBody);
};
const headersAreMatching = (expectedHeaders, actualHeaders) => {
    return (0, data_1.objectsShouldIntercept)(expectedHeaders, actualHeaders);
};
//# sourceMappingURL=index.js.map