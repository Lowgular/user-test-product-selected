// import { Locator, expect } from '@playwright/test';
// import { SimpleElement } from './atoms';
// import { filter, findOrThrow, forEach } from './utils';
// // export class ClickThroughAll<T extends ClickableElement> {
// //   constructor(private readonly list: ListElement<T>) {}
// //   async clickThroughAll(callBack: (index: number) => Promise<void>) {
// //     for (let i = 0; i < (await this.list.length()); i++) {
// //       await (await this.list.getNthElement(i)).click();
// //       await callBack(i);
// //     }
// //   }
// // }
// export class ListElement<T extends SimpleElement> {
//   constructor(
//     protected readonly locator: Locator,
//     protected readonly getChildren: (parent: Locator) => Promise<T[]>
//   ) {}
//   async forEachChild(callBack: (child: T, index: number) => Promise<void>) {
//     const allItems = await this.getChildren(this.locator);
//     await forEach(allItems, callBack);
//   }
//   // async sort(
//   //   criterion: (el: T) => Promise<number>,
//   //   direction: 'asc' | 'desc'
//   // ): Promise<T[]> {
//   //   return await sortData(
//   //     await this.getChildren(this.locator),
//   //     criterion,
//   //     direction
//   //   );
//   // }
//   async find(
//     callBack: (child: T, index: number) => Promise<boolean>
//   ): Promise<T | undefined> {
//     const allItems = (await this.getChildren(this.locator)) as T[];
//     for (let i = 0; i < allItems.length; i++) {
//       const isFound = await callBack(allItems[i], i);
//       if (isFound) {
//         return allItems[i];
//       }
//     }
//     return undefined;
//   }
//   async findOrThrow(
//     callBack: (child: T, index: number) => Promise<boolean>
//   ): Promise<T> {
//     return findOrThrow(await this.getChildren(this.locator), callBack);
//   }
//   async filter(
//     callBack: (child: T, index: number) => Promise<boolean>
//   ): Promise<ListElement<T>> {
//     return new ListElement(this.locator, async (locator: Locator) => {
//       const allItems = (await this.getChildren(locator)) as T[];
//       return filter(allItems, callBack);
//     });
//   }
//   async length() {
//     const allItems = await this.getChildren(this.locator);
//     return allItems.length;
//   }
//   async getNthElement(index: number): Promise<T> {
//     const children = await this.getChildren(this.locator);
//     return children[index] as T;
//   }
//   async expectToHaveLength(length: number) {
//     expect(await this.length()).toEqual(length);
//   }
// }
//# sourceMappingURL=list.js.map