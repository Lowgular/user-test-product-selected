// import { Locator, expect } from 'playwright/test';
// import { ElementLocator } from '../locator';
// import { TextElement } from './atoms';
// export class ContainerElement extends TextElement {
//   get elementLocator(): ElementLocator {
//     return new ElementLocator(this.locator);
//   }
// }
// export class CssClassBasedActivableElement extends ContainerElement {
//   constructor(locator: Locator) {
//     super(locator);
//   }
//   async isActive(cssClass: string): Promise<boolean> {
//     return await elementClassContainsString(this.locator, cssClass);
//   }
//   async expectActive(cssClass: string): Promise<void> {
//     expect(await this.isActive(cssClass)).toEqual(true);
//   }
//   async expectInactive(cssClass: string): Promise<void> {
//     expect(await this.isActive(cssClass)).toEqual(false);
//   }
// }
// export class CssClassBasedSelectableElement extends ContainerElement {
//   constructor(locator: Locator) {
//     super(locator);
//   }
//   async isSelected(cssClass: string): Promise<boolean> {
//     return await elementClassContainsString(this.locator, cssClass);
//   }
//   async expectSelected(cssClass: string): Promise<void> {
//     expect(await this.isSelected(cssClass)).toEqual(true);
//   }
//   async expectUnselected(cssClass: string): Promise<void> {
//     expect(await this.isSelected(cssClass)).toEqual(false);
//   }
// }
// // export class CssClassBasedDisableableElement extends ContainerElement {
// //   async isDisabled(disableCssClass: string): Promise<boolean> {
// //     return elementClassContainsString(this.locator, disableCssClass);
// //   }
// // }
// const elementClassContainsString = async (
//   locator: Locator,
//   className: string
// ) => {
//   const cssClass = await locator.getAttribute('class');
//   return cssClass !== null && cssClass.includes(className);
// };
//# sourceMappingURL=container.js.map