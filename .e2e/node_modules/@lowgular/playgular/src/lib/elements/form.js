// import { Locator, expect } from '@playwright/test';
// import { StringOrRegExp } from '../data';
// import { coerceRegexp } from '../matchers';
// import { SimpleElement } from './atoms';
// import { ContainerElement } from './container';
// import { ListElement } from './list';
// import { filter, findElementByLabel, findOrThrow, forEach } from './utils';
// class DisablableFormControl extends SimpleElement {
//   async isDisabled(value = true) {
//     const disabled = await this.getAttribute('disabled');
//     if (value === true) {
//       return disabled !== null;
//     }
//     return disabled === null;
//   }
//   async expectToBeDisabled(value = true) {
//     expect(await this.isDisabled(true)).toEqual(value);
//   }
// }
// export class SimpleFormControl extends DisablableFormControl {
//   async getValue() {
//     return await this.locator.inputValue();
//   }
//   async expectValue(expectedValue: StringOrRegExp) {
//     await expectValue(this.locator, expectedValue);
//   }
// }
// class CheckableFormControl extends SimpleFormControl {
//   async check(): Promise<void> {
//     await this.locator.check();
//   }
//   async uncheck(): Promise<void> {
//     await this.locator.uncheck();
//   }
//   async isChecked(value = true): Promise<boolean> {
//     return (await this.locator.isChecked()) === value;
//   }
//   async expectChecked(isChecked = true): Promise<void> {
//     expect(await this.isChecked(isChecked)).toEqual(true);
//   }
// }
// export class RadioFormControl extends CheckableFormControl {}
// export class CheckboxFormControl extends CheckableFormControl {}
// export class InputFormControl extends SimpleFormControl {
//   async setValue(value: string | number) {
//     // @todo pressSequentially
//     await fillInput(this.locator, `${value}`);
//     await removeFocusFromElement(this.locator);
//   }
//   async isEmpty(value = true) {
//     const currentValue = await this.getAttribute('value');
//     if (value === true) {
//       return currentValue === null;
//     }
//     return currentValue !== null;
//   }
//   async expectEmpty(value = true) {
//     expect(await this.isEmpty(true)).toEqual(value);
//   }
//   async expectAttributeType(type: string) {
//     await expectElementAttribute(this.locator, 'type', type);
//   }
//   async focus() {
//     await this.locator.focus();
//   }
//   async blur() {
//     await this.locator.blur();
//   }
// }
// export class SelectFormControl extends SimpleFormControl {
//   async selectOptionByLabel(label: string) {
//     await this.locator.selectOption({ label });
//   }
//   async selectOptionByValue(value: string) {
//     await this.locator.selectOption({ value });
//   }
//   async selectOptionByIndex(index: number) {
//     await this.locator.selectOption({ index });
//   }
// }
// // https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control
// export class RadioGroupFormControl {
//   constructor(
//     protected readonly locator: Locator,
//     protected readonly labelLists: ListElement<ContainerElement>
//   ) {}
//   private async findOrThrow(
//     callBack: (child: RadioFormControl, index: number) => Promise<boolean>
//   ): Promise<RadioFormControl> {
//     return findOrThrow(await this.makeRadios(), callBack);
//   }
//   private async makeRadios() {
//     return (await this.locator.all()).map((loc) => new RadioFormControl(loc));
//   }
//   async expectValue(value: StringOrRegExp) {
//     const checkedRadio = await this.findOrThrow(
//       async (r) => await r.isChecked()
//     );
//     expect(await checkedRadio.getValue()).toMatch(coerceRegexp(value));
//   }
//   async selectByValue(value: StringOrRegExp) {
//     const radio = await this.findOrThrow(
//       async (r) => (await r.getValue()).match(coerceRegexp(value)) !== null
//     );
//     await radio.check();
//   }
//   async selectByIndex(index: number) {
//     const radio = await this.findOrThrow(async (r, i) => i === index);
//     await radio.check();
//   }
//   async selectByLabel(label: StringOrRegExp) {
//     const radio = await findElementByLabel(
//       label,
//       await this.makeRadios(),
//       this.labelLists
//     );
//     await radio.check();
//   }
// }
// export class SelectMultipleFormControl extends SimpleElement {
//   async expectValues(expectedValues: StringOrRegExp[]) {
//     const checked = await this.getSelectedValues();
//     expect(checked.length).toEqual(expectedValues.length);
//     await forEach(checked, async (val) => {
//       const found = expectedValues.find(
//         (v) => val?.match(coerceRegexp(v)) !== null
//       );
//       expect(found).not.toBeUndefined();
//     });
//   }
//   async selectAll() {
//     await forEach(await this.getOptionLocators(), async (oLoc) => {
//       await this.selectOptionLocator(oLoc, await this.getSelectedValues());
//     });
//   }
//   async unselectAll() {
//     await forEach(await this.getOptionLocators(), async (oLoc) => {
//       await this.unselectOptionLocator(oLoc, await this.getSelectedValues());
//     });
//   }
//   async selectByIndices(indices: number[]) {
//     await forEach(await this.getOptionLocators(), async (oLoc, i) => {
//       if (indices.includes(i)) {
//         await this.selectOptionLocator(oLoc, await this.getSelectedValues());
//       }
//     });
//   }
//   async unselectByIndices(indices: number[]) {
//     await forEach(await this.getOptionLocators(), async (oLoc, i) => {
//       if (indices.includes(i)) {
//         await this.unselectOptionLocator(oLoc, await this.getSelectedValues());
//       }
//     });
//   }
//   async selectByLabels(labels: StringOrRegExp[]) {
//     await forEach(await this.getOptionLocators(), async (oLoc) => {
//       const label = await oLoc.textContent();
//       await this.findOptionAndSelect(label, labels, oLoc);
//     });
//   }
//   async unselectByLabels(labels: StringOrRegExp[]) {
//     await forEach(await this.getOptionLocators(), async (oLoc) => {
//       const label = await oLoc.textContent();
//       await this.findOptionAndUnselect(label, labels, oLoc);
//     });
//   }
//   async selectByValues(values: StringOrRegExp[]) {
//     await forEach(await this.getOptionLocators(), async (oLoc) => {
//       const value = await oLoc.getAttribute('value');
//       await this.findOptionAndSelect(value, values, oLoc);
//     });
//   }
//   async unselectByValues(values: StringOrRegExp[]) {
//     await forEach(await this.getOptionLocators(), async (oLoc) => {
//       const value = await oLoc.getAttribute('value');
//       await this.findOptionAndUnselect(value, values, oLoc);
//     });
//   }
//   private async getOptionLocators(onlyChecked = false): Promise<Locator[]> {
//     return await this.locator
//       .locator('option' + (onlyChecked ? ':checked' : ''))
//       .all();
//   }
//   private async getOptionValue(oLoc: Locator) {
//     return (await oLoc.getAttribute('value')) ?? (await oLoc.textContent());
//   }
//   private async getSelectedValues() {
//     const selectedValues = [] as string[];
//     await forEach(await this.getOptionLocators(true), async (selLoc) => {
//       selectedValues.push((await this.getOptionValue(selLoc)) as string);
//     });
//     return selectedValues;
//   }
//   private async findOptionAndSelect(
//     itemVal: string | null,
//     itemVals: StringOrRegExp[],
//     oLoc: Locator
//   ) {
//     if (itemVal !== null) {
//       const found = itemVals.find(
//         (iv) => itemVal.match(coerceRegexp(iv)) !== null
//       );
//       if (found) {
//         await this.selectOptionLocator(oLoc, await this.getSelectedValues());
//       }
//     }
//   }
//   private async findOptionAndUnselect(
//     itemVal: string | null,
//     itemVals: StringOrRegExp[],
//     oLoc: Locator
//   ) {
//     if (itemVal !== null) {
//       const found = itemVals.find(
//         (iv) => itemVal.match(coerceRegexp(iv)) !== null
//       );
//       if (found) {
//         await this.unselectOptionLocator(oLoc, await this.getSelectedValues());
//       }
//     }
//   }
//   private async selectOptionLocator(oLoc: Locator, selectedValues: string[]) {
//     const optionVal = (await this.getOptionValue(oLoc)) as string;
//     if (!selectedValues.includes(optionVal)) {
//       await oLoc.click({ modifiers: ['Control'] });
//     }
//   }
//   private async unselectOptionLocator(oLoc: Locator, selectedValues: string[]) {
//     const optionVal = (await this.getOptionValue(oLoc)) as string;
//     if (selectedValues.includes(optionVal)) {
//       await oLoc.click({ modifiers: ['Control'] });
//     }
//   }
// }
// export class CheckboxGroupFormControl {
//   constructor(
//     protected readonly locator: Locator,
//     protected readonly labelLists: ListElement<ContainerElement>
//   ) {}
//   async expectValues(values: StringOrRegExp[]) {
//     const checked = await this.filter(async (c) => await c.isChecked());
//     expect(checked.length).toEqual(values.length);
//     // Improve error messages
//     for (let i = 0; i < values.length; i++) {
//       const checkbox = await this.findOrThrow(
//         async (c) =>
//           (await c.getValue()).match(coerceRegexp(values[i])) !== null
//       );
//       expect(await checkbox.isChecked()).toEqual(true);
//     }
//   }
//   async selectAll() {
//     await forEach(await this.makeCheckboxes(), async (child) => {
//       child.check();
//     });
//   }
//   async unselectAll() {
//     await forEach(await this.makeCheckboxes(), async (child) => {
//       await child.uncheck();
//     });
//   }
//   async selectByValues(values: StringOrRegExp[]) {
//     await forEach(await this.makeCheckboxes(), async (child, i) => {
//       const value = await child.getValue();
//       const found = values.find((v) => value.match(coerceRegexp(v)) !== null);
//       if (found) {
//         await child.check();
//       }
//     });
//   }
//   async unselectByValues(values: StringOrRegExp[]) {
//     await forEach(await this.makeCheckboxes(), async (child, i) => {
//       const value = await child.getValue();
//       const found = values.find((v) => value.match(coerceRegexp(v)) !== null);
//       if (found) {
//         await child.uncheck();
//       }
//     });
//   }
//   async selectByIndices(indices: number[]) {
//     await forEach(await this.makeCheckboxes(), async (child, i) => {
//       if (indices.includes(i)) {
//         await child.check();
//       }
//     });
//   }
//   async unselectByIndices(indices: number[]) {
//     await forEach(await this.makeCheckboxes(), async (child, i) => {
//       if (indices.includes(i)) {
//         await child.uncheck();
//       }
//     });
//   }
//   async selectByLabels(labels: StringOrRegExp[]) {
//     for (let i = 0; i < labels.length; i++) {
//       const label = labels[i];
//       const checkbox = await findElementByLabel(
//         label,
//         await this.makeCheckboxes(),
//         this.labelLists
//       );
//       await checkbox.check();
//     }
//   }
//   async unselectByLabels(labels: StringOrRegExp[]) {
//     for (let i = 0; i < labels.length; i++) {
//       const label = labels[i];
//       const checkbox = await findElementByLabel(
//         label,
//         await this.makeCheckboxes(),
//         this.labelLists
//       );
//       await checkbox.uncheck();
//     }
//   }
//   private async filter(
//     callBack: (child: CheckboxFormControl, index: number) => Promise<boolean>
//   ): Promise<CheckboxFormControl[]> {
//     return filter(await this.makeCheckboxes(), callBack);
//   }
//   private async findOrThrow(
//     callBack: (child: RadioFormControl, index: number) => Promise<boolean>
//   ): Promise<RadioFormControl> {
//     return findOrThrow(await this.makeCheckboxes(), callBack);
//   }
//   private async makeCheckboxes() {
//     return (await this.locator.all()).map(
//       (loc) => new CheckboxFormControl(loc)
//     );
//   }
// }
// interface FileOptions {
//   /**
//    * File name
//    */
//   name: string;
//   /**
//    * File type
//    */
//   mimeType: string;
//   /**
//    * File content
//    */
//   buffer: Buffer;
// }
// export class FileFormControl extends SimpleFormControl {
//   async setValue(files: string | string[] | FileOptions | FileOptions[]) {
//     await this.locator.setInputFiles(files);
//   }
// }
// const fillInput = async (locator: Locator, value: string) => {
//   await locator.click();
//   await locator.fill(value);
// };
// const removeFocusFromElement = async (locator: Locator) => {
//   await locator.evaluate((el) => el.blur());
// };
// const expectValue = async (locator: Locator, expectedValue: StringOrRegExp) => {
//   const value = await locator.inputValue();
//   expect(value).toMatch(coerceRegexp(expectedValue));
// };
// const expectElementAttribute = async (
//   locator: Locator,
//   attr: string,
//   val: string | undefined
// ) => {
//   const actualAttr = await locator.getAttribute(attr);
//   if (typeof val === 'string') {
//     expect(actualAttr).toEqual(val);
//   } else {
//     expect(actualAttr).toBeNull();
//   }
// };
//# sourceMappingURL=form.js.map