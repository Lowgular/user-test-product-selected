// import 'reflect-metadata';
// import { container } from 'tsyringe';
// import { AppConfig } from './core';
// import { HttpClient } from './http';
// import { ElementLocator } from './locator';
// import { Router } from './routing';
// import { Screenshooter } from './screenshooter';
// import { CookieStorage, LocalStorage } from './storage';
// const registerFrameworkDependencies = (
//   page: any,
//   browserContext: any,
//   appUrl: string
// ) => {
//   container.registerInstance(
//     ElementLocator,
//     new ElementLocator(page.locator('body'))
//   );
//   container.registerInstance(Router, new Router(page, appUrl));
//   container.registerInstance(Screenshooter, new Screenshooter(page));
//   container.registerInstance(HttpClient, new HttpClient(page));
//   container.registerInstance(LocalStorage, new LocalStorage(page));
//   container.registerInstance(
//     CookieStorage,
//     new CookieStorage(browserContext, appUrl)
//   );
// };
// const resolveComponentForRoute = <C>(route: string, routes: any): C => {
//   if (!(route in routes)) {
//     throw new Error(`Route ${route} not found`);
//   }
//   const componentKey = (routes as any)[route];
//   try {
//     return container.resolve<C>(componentKey);
//   } catch (e: any) {
//     throw new Error(`Component for ${route} not found`);
//   }
// };
// export const givenApp = async (
//   page: any,
//   browser: any,
//   config: AppConfig
// ): Promise<any> => {
//   return {};
//   // const browserContext = await browser.newContext();
//   // registerFrameworkDependencies(page, browserContext, config.appUrl);
//   // container.registerInstance(HttpClient, new HttpClient(page));
//   // (config.module.providers || []).forEach((provider) => {
//   //   container.register(provider, provider);
//   // });
//   // (config.module.declarations || []).forEach((declaration) => {
//   //   container.register(declaration, declaration);
//   // });
//   // return {
//   //   inject: <T>(klass: Constructable<T>) => container.resolve(klass),
//   //   waitForTimeout: async (timeout: number) =>
//   //     await page.waitForTimeout(timeout),
//   //   resolveComponentForRoute: (route: string) =>
//   //     resolveComponentForRoute(route, config.routes),
//   //   navigateToRoute: async (route: string) => {
//   //     await container.resolve(Router).navigateAndWait(route);
//   //     return resolveComponentForRoute(route, config.routes);
//   //   },
//   //   evaluate: async (fn, arg) => page.evaluate(fn, arg),
//   // };
// };
//# sourceMappingURL=setup.js.map